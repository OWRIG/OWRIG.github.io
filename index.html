<!DOCTYPE html>

<html lang="zh-CN">

<head>
  
  <title>Rig的博客</title>
  <meta charset="UTF-8">
  <meta name="description" content="用于分享生活">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  
  

  <link rel="shortcut icon" href="/favicon.ico" type="image/png" />
  <meta name="description" content="用于分享生活">
<meta property="og:type" content="website">
<meta property="og:title" content="Rig的博客">
<meta property="og:url" content="http://rigblog.top/index.html">
<meta property="og:site_name" content="Rig的博客">
<meta property="og:description" content="用于分享生活">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="rig">
<meta name="twitter:card" content="summary">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/combine/gh/nexmoe/nexmoe.github.io@latest/css/style.css,npm/highlight.js@9.15.8/styles/atom-one-dark.css,gh/nexmoe/nexmoe.github.io@latest/lib/mdui_043tiny/css/mdui.css,gh/nexmoe/nexmoe.github.io@latest/lib/iconfont/iconfont.css" crossorigin>
  
  <!--<link rel="stylesheet" href="/css/style.css?v=1584084642466">-->

   
    <style>
      .nexmoe-avatar img:hover {
        -webkit-transform: rotateZ(360deg);
        -moz-transform: rotateZ(360deg);
        transform: rotateZ(360deg);
      }	
    </style>
  
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="mdui-drawer-body-left">
  
  <div id="nexmoe-background">
    <div class="nexmoe-bg" style="background-image: url(https://s2.ax1x.com/2020/02/18/3ki2wV.jpg)"></div>
    <div class="mdui-appbar mdui-shadow-0">
      <div class="mdui-toolbar">
        <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
        <div class="mdui-toolbar-spacer"></div>
        <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
        <a href="/" title="rig" class="mdui-btn mdui-btn-icon"><img src="https://s2.ax1x.com/2020/02/18/3kpyVS.jpg" alt="rig"></a>
       </div>
    </div>
  </div>
  <div id="nexmoe-header">
      <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="rig">
            <img src="https://s2.ax1x.com/2020/02/18/3kpyVS.jpg" alt="rig" alt="rig">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>2</div>
        <div><span>标签</span>0</div>
        <div><span>分类</span>0</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/archives" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/about.html" title="关于博客">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple" href="/PY.html" title="我的朋友">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                我的朋友
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
  
  <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        <form id="search_form" action_e="https://cn.bing.com/search?q=site:nexmoe.com" onsubmit="return search();">
            <label><input id="search_value" name="q" type="search" placeholder="搜索"></label>
        </form>
    </div>
</div>
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">社交按钮</h3>
    <div class="nexmoe-widget nexmoe-social">
        <a class="mdui-ripple" href="https://space.bilibili.com/73892108" target="_blank" mdui-tooltip="{content: '哔哩哔哩'}" style="color: rgb(231, 106, 141);background-color: rgba(231, 106, 141, .15);">
            <i class="nexmoefont icon-bilibili"></i>
        </a><a class="mdui-ripple" href="https://github.com/X-RIG/" target="_blank" mdui-tooltip="{content: 'GitHub'}" style="color: rgb(25, 23, 23);background-color: rgba(25, 23, 23, .15);">
            <i class="nexmoefont icon-github"></i>
        </a>
    </div>
</div>
  
  

  
  
  
  
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li></ul>
    </div>
  </div>


  

</aside>


    <div class="nexmoe-copyright">
        &copy; 2020 rig
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://nexmoe.com/hexo-theme-nexmoe.html" target="_blank">Nexmoe</a>
    </div>
</div><!-- .nexmoe-drawer -->
  </div>
 
  <div id="nexmoe-content">
    <div class="nexmoe-primary">
        <section class="nexmoe-posts">
    
    <div class="nexmoe-post">
        <a href="/2020/03/13/JAVA%E7%AC%94%E8%AE%B0/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://s2.ax1x.com/2020/02/18/3ki2wV.jpg" data-sizes="auto" alt="JAVA笔记" class="lazyload">
                    <h1>JAVA笔记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年03月13日</a>
            <a><i class="nexmoefont icon-areachart"></i>3.5k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 16 分钟</a>
        </div>

        <article>
            
                <a id="more"></a>

<h1 id="JAVA笔记"><a href="#JAVA笔记" class="headerlink" title="JAVA笔记"></a>JAVA笔记</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>程序通过改变变量改变整个程序</p>
<p>在java中变量需要先声明才能使用</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量的值不可修改</p>
<p>final可以用于声明属性，方法和类，当final修饰属性时，代表该属性一旦被分配内存空间就必须初始化。</p>
<p>常量名必须大写</p>
<pre><code class="java">final double PI = 3.14;</code></pre>
<p>常量也可以先声明，再进行赋值，但只能赋值一次</p>
<pre><code class="java">public class FinalVar{
    public static void main(String[] args){
        final String FINAL_STRING=&quot;shiyanlou&quot;;
        System.out.println(FINAL_STRING);
    }
}</code></pre>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">默认值</th>
<th align="center">存储格式</th>
<th align="center">数据范围</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">short</td>
<td align="center">0</td>
<td align="center">2 个字节</td>
<td align="center">-32,768 到 32767</td>
<td>Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">0</td>
<td align="center">4 个字节</td>
<td align="center">-2,147,483,648 到 2,147,483,647</td>
<td>Integer</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">0</td>
<td align="center">1 个字节</td>
<td align="center">-128 到 127</td>
<td>Byte</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">空</td>
<td align="center">2 个字节</td>
<td align="center">Unicode 的字符范围：’\u0000’（即为 0）到’\uffff’（即为 65,535）</td>
<td>Character</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">0L 或 0l</td>
<td align="center">8 个字节</td>
<td align="center">-9,223,372,036,854,775,808 到 9,223,372,036, 854,775,807</td>
<td>Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">0.0F 或 0.0f</td>
<td align="center">4 个字节</td>
<td align="center">32 位 IEEEE-754 单精度范围</td>
<td>Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">0.0 或 0.0D(d)</td>
<td align="center">8 个字节</td>
<td align="center">64 位 IEEE-754 双精度范围</td>
<td>Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">false</td>
<td align="center">1 位</td>
<td align="center">true 或 false</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>byte、short、int、long 四种基本数据类型表示整数，需要注意的是 long 类型，使用 long 修饰的变量需要在数值后面加上 L 或者 l，比如<code>long num=1L;</code>，一般使用大写 L，为了避免小写 l 与数值 1 混淆。</p>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>float 和 double 类型表示浮点数，即可以表示小数部分。需要注意的是 float 类型的数值后面需要加上 F 或者 f，否则会被当成 double 类型处理。double 类型的数值可以加上 D 或 d，也可以不加。</p>
<h4 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h4><p>char 类型用于表示单个字符。需要将字符用单引号括起来<code>char a=&#39;a&#39;</code>，char 可以和整数互相转换，如果字符<code>a</code>也可以写成<code>char a=97</code>。也可以用十六进制表示<code>char a = &#39;\u0061&#39;</code>。</p>
<h4 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h4><p>boolean 类型（布尔类型）用于表示真值<code>true</code>或者假值<code>false</code>，Java 中布尔值不能和整数类型或者其它类型互相转换。</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Java 中使用 String 类来定义一个字符串，字符串是<code>常量</code>，它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。</p>
<p>String 对象的初始化格式有如下两种：</p>
<pre><code>String s0 = &quot;abc&quot;;

String s1 = new String(&quot;abd&quot;);</code></pre><h4 id="计算字符串长度"><a href="#计算字符串长度" class="headerlink" title="计算字符串长度"></a>计算字符串长度</h4><pre><code class="java">//方法原型
public int length(){
String s1 = &quot;abc&quot;;
String s2 = &quot;Java语言&quot;;
int len1 = s1.length();
int len2 = s2.length();
}</code></pre>
<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><p>equals() 方法,该方法的作用是判断两个字符串对象的内容是否相同。如果相同则返回 true，否则返回 false。</p>
<p>如果想忽略掉大小写关系，比如：java 和 Java 是一样的，那怎么办呢？可以调用<code>equalsIgnoreCase()</code>方法，其用法与 equals 一致，不过它会忽视大小写。</p>
<pre><code class="java">public class StringTest {
    public static void main(String[] args){
        String s = new String(&quot;Java&quot;);
        String m = &quot;java&quot;;
        System.out.println(&quot;用equals()比较，java和Java结果为&quot;+s.equals(m));
        System.out.println(&quot;用equalsIgnoreCase()比较，java和Java结果为&quot;+s.equalsIgnoreCase(m));
    }
}</code></pre>
<p>使用<code>&quot;==&quot;</code>比较的是两个对象在内存中存储的地址是否一样。例如:</p>
<pre><code class="java">         String s1 = &quot;abc&quot;;
         String s2 = new String(&quot;abc&quot;);
         boolean b = (s1 == s2);</code></pre>
<h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><p>字符串连接有两种方法：</p>
<ol>
<li>使用<code>+</code>，比如<code>String s = &quot;Hello &quot; + &quot;World!&quot;</code></li>
<li>使用 String 类的 concat() 方法</li>
</ol>
<pre><code class="java">String s0 = new String(&quot;Hello &quot;);
String s1 = &quot;World&quot; + &quot;!&quot;;   //+号连接
String s2 = s0.concat(s1); //concat()方法连接
System.out.println(s2);</code></pre>
<h4 id="charAt-方法"><a href="#charAt-方法" class="headerlink" title="charAt()方法"></a>charAt()方法</h4><p>charAt()方法的作用是按照索引值(规定字符串中第一个字符的索引值是 0，第二个字符的索引值是 1，依次类推)，获得字符串中的指定字符。例如：</p>
<pre><code class="java">     String s = &quot;abc&quot;;
     char c = s.charAt(1);</code></pre>
<h4 id="字符串常用提取方法"><a href="#字符串常用提取方法" class="headerlink" title="字符串常用提取方法"></a>字符串常用提取方法</h4><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">返回值</th>
<th align="center">功能描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">indexOf(char ch)</td>
<td align="center">int</td>
<td align="center">搜索字符 ch 第一次出现的索引</td>
</tr>
<tr>
<td align="center">indexOf(String value)</td>
<td align="center">int</td>
<td align="center">搜索字符串 value 第一次出现的索引</td>
</tr>
<tr>
<td align="center">lastIndexOf(char ch)</td>
<td align="center">int</td>
<td align="center">搜索字符 ch 最后一次出现的索引</td>
</tr>
<tr>
<td align="center">lastIndexOf(String value)</td>
<td align="center">int</td>
<td align="center">搜索字符串 value 最后一次出现的索引</td>
</tr>
<tr>
<td align="center">substring(int index)</td>
<td align="center">String</td>
<td align="center">提取从位置索引开始到结束的字符串</td>
</tr>
<tr>
<td align="center">substring(int beginindex, int endindex)</td>
<td align="center">String</td>
<td align="center">提取 beginindex 和 endindex 之间的字符串部分</td>
</tr>
<tr>
<td align="center">trim()</td>
<td align="center">String</td>
<td align="center">返回一个前后不含任何空格的调用字符串的副本</td>
</tr>
</tbody></table>
<pre><code class="java">public class StringTest {
    public static void main(String[] args) {
         String s = &quot;abcdefabc&quot;;
         System.out.println(&quot;字符a第一次出现的位置为&quot;+s.indexOf(&#39;a&#39;));
         System.out.println(&quot;字符串bc第一次出现的位置为&quot;+s.indexOf(&quot;bc&quot;));
         System.out.println(&quot;字符a最后一次出现的位置为&quot;+s.lastIndexOf(&#39;a&#39;));
         System.out.println(&quot;从位置3开始到结束的字符串&quot;+s.substring(3));
         System.out.println(&quot;从位置3开始到6之间的字符串&quot;+s.substring(3,6));
    }
}</code></pre>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><table>
<thead>
<tr>
<th>算术运算符</th>
<th>名称</th>
<th>描述</th>
<th>类型</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
<td>相加运算符两侧的值</td>
<td>双目运算符</td>
<td>a + b 等于 8</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>左操作数减去右操作数</td>
<td>双目运算符</td>
<td>a - b 等于 2</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>相乘操作符两侧的值</td>
<td>双目运算符</td>
<td>a * b 等于 15</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>左操作数除以右操作数</td>
<td>双目运算符</td>
<td>a / b 等于 1</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>左操作数除右操作数的余数</td>
<td>双目运算符</td>
<td>a % b 等于 2</td>
</tr>
<tr>
<td>++</td>
<td>自增</td>
<td>操作数的值增加 1</td>
<td>单目运算符</td>
<td>++i（或 i++） 等于 2</td>
</tr>
<tr>
<td>–</td>
<td>自减</td>
<td>操作数的值减少 1</td>
<td>单目运算符</td>
<td>–i（或 i–） 等于 0</td>
</tr>
</tbody></table>
<p>其中，自增(++)和自减(–)运算符有两种写法：<strong>前缀（++i,–i）</strong>和<strong>后缀（i++,i–）</strong>。</p>
<ul>
<li>前缀自增自减法(++i,–i): 先进行自增或者自减运算，再进行表达式运算。</li>
<li>后缀自增自减法(i++,i–): 先进行表达式运算，再进行自增或者自减运算</li>
</ul>
<pre><code class="java">public class ArithmeticOperation {
    public static void main(String args[]) {
        int a = 5;
        int b = 3;
        int c = 3;
        int d = 3;
        System.out.println(&quot;a + b = &quot; + (a + b));
        System.out.println(&quot;a - b = &quot; + (a - b));
        System.out.println(&quot;a * b = &quot; + (a * b));
        System.out.println(&quot;a / b = &quot; + (a / b));
        System.out.println(&quot;a % b = &quot; + (a % b));
        System.out.println(&quot;a++ = &quot; + (a++));
        System.out.println(&quot;++a = &quot; + (++a));
        System.out.println(&quot;b-- = &quot; + (b--));
        System.out.println(&quot;--b = &quot; + (--b));
        System.out.println(&quot;c++ = &quot; + (c++));
        System.out.println(&quot;++d = &quot; + (++d));
    }
}

a + b = 8
a - b = 2
a * b = 15
a / b = 1
a % b = 2
a++ = 5
++a = 7
b-- = 3
--b = 1
c++ = 3
++d = 4</code></pre>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>Java 定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。位运算时先转换为二进制，再按位运算。</p>
<p>表格中的例子中，变量<code>a</code>的值为 60，变量<code>b</code>的值为 13：</p>
<table>
<thead>
<tr>
<th>位运算符</th>
<th>名称</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>按位与</td>
<td>如果相对应位都是 1，则结果为 1，否则为 0</td>
<td>（a＆b），得到 12，即 0000 1100</td>
</tr>
<tr>
<td>丨</td>
<td>按位或</td>
<td>如果相对应位都是 0，则结果为 0，否则为 1</td>
<td>（ a 丨 b ）得到 61，即 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>如果相对应位值相同，则结果为 0，否则为 1</td>
<td>（a^b）得到 49，即 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>按位补</td>
<td>翻转操作数的每一位，即 0 变成 1，1 变成 0</td>
<td>（〜a）得到-61，即 1100 0011</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>按位左移</td>
<td>左操作数按位左移右操作数指定的位数</td>
<td>a&lt;&lt;2 得到 240，即 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>按位右移</td>
<td>左操作数按位右移右操作数指定的位数</td>
<td>a&gt;&gt;2 得到 15 即 1111</td>
</tr>
<tr>
<td>&gt;&gt;&gt;</td>
<td>按位右移补零</td>
<td>左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充</td>
<td>a&gt;&gt;&gt;2 得到 15 即 0000 1111</td>
</tr>
</tbody></table>
<pre><code class="java">public class BitOperation {
    public static void main(String args[]) {
        int a = 60;
        int b = 13;
        System.out.println(&quot;a &amp; b = &quot; + (a &amp; b));
        System.out.println(&quot;a | b = &quot; + (a | b));
        System.out.println(&quot;a ^ b = &quot; + (a ^ b));
        System.out.println(&quot;~a = &quot; + (~a));
        System.out.println(&quot;a &lt;&lt; 2 = &quot; + (a &lt;&lt; 2));
        System.out.println(&quot;a &gt;&gt; 2 = &quot; + (a &gt;&gt; 2));
        System.out.println(&quot;a &gt;&gt;&gt; 2 = &quot; + (a &gt;&gt;&gt; 2));
    }
}

a &amp; b = 12
a | b = 61
a ^ b = 49
~a = -61
a &lt;&lt; 2 = 240
a &gt;&gt; 2 = 15
a &gt;&gt;&gt; 2 = 15</code></pre>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符是通过运算符将操作数或等式进行逻辑判断的语句。</p>
<p>假设布尔变量 a 为真，变量 b 为假：</p>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>名称</th>
<th>描述</th>
<th>类型</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>与</td>
<td>当且仅当两个操作数都为真，条件才为真</td>
<td>双目运算符</td>
<td>（a &amp;&amp; b）为假</td>
</tr>
<tr>
<td>｜｜</td>
<td>或</td>
<td>两个操作数任何一个为真，条件为真</td>
<td>双目运算符</td>
<td>（a ｜｜ b）为真</td>
</tr>
<tr>
<td>！</td>
<td>非</td>
<td>用来反转操作数的逻辑状态。如果条件为真，则逻辑非运算符将得到假</td>
<td>单目运算符</td>
<td>（!a）为假</td>
</tr>
<tr>
<td>^</td>
<td>异或</td>
<td>如果两个操作数逻辑相同，则结果为假，否则为真</td>
<td>双目运算符</td>
<td>（a ^ b）为真</td>
</tr>
</tbody></table>
<pre><code class="java">public class LogicOperation {
    public static void main(String args[]) {
        boolean a = true;
        boolean b = false;
        System.out.println(&quot;a &amp;&amp; b = &quot; + (a &amp;&amp; b));
        System.out.println(&quot;a || b = &quot; + (a || b));
        System.out.println(&quot;!a = &quot; + (!a));
        System.out.println(&quot;a ^ b = &quot; + (a ^ b));
    }
}

a &amp;&amp; b = false
a || b = true
!a = false
a ^ b = true</code></pre>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>关系运算符生成的是一个 boolean（布尔）结果，它们计算的是操作数的值之间的关系。如果关系是真实的，结果为 true（真），否则，结果为 false（假）。</p>
<p>表格中的例子中，假设变量 a 为 3，变量 b 为 5：</p>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>名称</th>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>等于</td>
<td>判断两个操作数的值是否相等，如果相等则条件为真</td>
<td>（a == b）为 false</td>
</tr>
<tr>
<td>！=</td>
<td>不等于</td>
<td>判断两个操作数的值是否相等，如果值不相等则条件为真</td>
<td>(a != b) 为 true</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>判断左操作数的值是否大于右操作数的值，如果是那么条件为真</td>
<td>（a &gt; b）为 false</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>判断左操作数的值是否小于右操作数的值，如果是那么条件为真</td>
<td>（a &lt; b）为 true</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
<td>判断左操作数的值是否大于或等于右操作数的值，如果是那么条件为真</td>
<td>（a &gt;= b）为 false</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
<td>判断左操作数的值是否小于或等于右操作数的值，如果是那么条件为真</td>
<td>（a &lt;= b）为 true</td>
</tr>
</tbody></table>
<h5 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h5><p><strong>语法格式： 布尔表达式？表达式 1 : 表达式 2</strong></p>
<p>运算过程：如果布尔表达式的值为<code>true</code> ，则返回 <code>表达式1</code> 的值，否则返回 <code>表达式2</code> 的值。</p>
<pre><code class="java">public class RelationalOperation {
    public static void main(String args[]) {
        int a = 3;
        int b = 5;
        System.out.println(&quot;a == b = &quot; + (a == b));
        System.out.println(&quot;a != b = &quot; + (a != b));
        System.out.println(&quot;a &gt; b = &quot; + (a &gt; b));
        System.out.println(&quot;a &lt; b = &quot; + (a &lt; b));
        System.out.println(&quot;a &gt;= b = &quot; + (a &gt;= b));
        System.out.println(&quot;a &lt;= b = &quot; + (a &lt;= b));
        System.out.println(&quot;a &gt; b ? a : b = &quot; + (a &gt; b ? a : b));
    }
}

a == b = false
a != b = true
a &gt; b = false
a &lt; b = true
a &gt;= b = false
a &lt;= b = true
a &gt; b ? a : b = 5</code></pre>
<p><strong>强调</strong>：</p>
<ul>
<li><code>==</code>和<code>!=</code>适用于所有的基本数据类型，其他关系运算符不适用于<code>boolean</code>，因为 boolean 值只有<code>true</code>和<code>false</code>，比较没有任何意义。</li>
<li><code>==</code>和<code>!=</code>也适用于所有对象，可以比较对象的<code>引用</code>是否相同。</li>
</ul>
<p><strong>引用：Java 中一切都是对象，但操作的标识符实际是对象的一个引用。</strong></p>
<h3 id="关键字和语句"><a href="#关键字和语句" class="headerlink" title="关键字和语句"></a>关键字和语句</h3><p>Java 的关键字对 java 的编译器有特殊的意义，他们用来表示一种数据类型，或者表示程序的结构等，关键字不能用作变量名、方法名、类名、包名。</p>
<p><img data-sizes="auto" data-src="https://doc.shiyanlou.com/document-uid79144labid1048timestamp1434006344973.png/wm" alt="avatar" class="lazyload"></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Java 中的方法，可以将其看成一个功能的集合，它们是为了解决特定问题的代码组合。</p>
<pre><code class="java">访问修饰符 返回值类型 方法名(参数列表){
    方法体
}
public void functionName(Object arg){

}</code></pre>
<p>在上面的语法说明中：</p>
<p>1.<strong>访问修饰符</strong>：代表方法允许被访问的权限范围， 可以是 public、protected、private 或者省略（default） ，其中 public 表示该方法可以被其他任何代码调用。</p>
<p>2.<strong>返回值类型</strong>：方法返回值的类型，如果方法不返回任何值，则返回值类型指定为 void (代表无类型)；如果方法具有返回值，则需要指定返回值的类型，并且在方法体中使用 return 语句返回值。</p>
<p>3.<strong>方法名</strong>：是方法的名字，必须使用合法的标识符。</p>
<p>4.<strong>参数列表</strong>：是传递给方法的参数列表，参数可以有多个，多个参数间以逗号隔开，每个参数由参数类型和参数名组成，以空格隔开。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</p>
<p>5.<strong>方法体</strong>：方法体包含具体的语句，定义该方法的功能。</p>
<p>根据方法是否带参、是否带返回值，可将方法分为四类：</p>
<ul>
<li>无参无返回值方法</li>
<li>无参带返回值方法</li>
<li>带参无返回值方法</li>
<li>带参带返回值方法</li>
</ul>
<p>当方法定义好之后，需要调用才可以生效，我们可以通过 main 方法（main 方法是 Java 程序的入口，所以需要用它来调用）来调用它，比如：</p>
<pre><code class="java">public class MethodDemo{
    public static void main(String[] args){
        method();
    }
    //这里要加上static关键字 应为静态方法只能调用静态方法
    public static void method(){
        System.out.println(&quot;方法被调用&quot;);
    }
}</code></pre>

            
        </article>
    </div>
    
    <div class="nexmoe-post">
        <a href="/2020/03/13/python%E7%AC%94%E8%AE%B0/">
            
                <div class="nexmoe-post-cover mdui-ripple" style="padding-bottom: 66.66666666666666%;"> 
                    <img data-src="https://s2.ax1x.com/2020/02/18/3ki2wV.jpg" data-sizes="auto" alt="python笔记" class="lazyload">
                    <h1>python笔记</h1>
                </div>
            
        </a>

        <div class="nexmoe-post-meta">
            <a><i class="nexmoefont icon-calendar-fill"></i>2020年03月13日</a>
            <a><i class="nexmoefont icon-areachart"></i>5.8k 字</a>
            <a><i class="nexmoefont icon-time-circle-fill"></i>大概 29 分钟</a>
        </div>

        <article>
            
                <a id="more"></a>

<h1 id="python-笔记"><a href="#python-笔记" class="headerlink" title="python 笔记"></a>python 笔记</h1><pre><code class="python">print（&#39;&#39;&#39;
打印多行内容
&#39;&#39;&#39;）</code></pre>
<pre><code class="python">print(&#39;你叫{}，今年{}岁了&#39;.format(name,age))</code></pre>
<p>input（’输入’）</p>
<p>如果字符串中还有引号,记得在单引号后加入转义符\</p>
<p>print(‘he said “today \ ‘s weather is good”‘)</p>
<p>索引也可以是负数，最后一个字符的索引是-1倒数第二个就是-2</p>
<p>注释为#</p>
<p>%    取模        返回除法的余数<br>**    幂           返回 x 的 y 次幂<br>//    取整除     返回商的整数部分（向下取整）</p>
<pre><code class="python">if ss:
    elif xx：
    else xx：</code></pre>
<pre><code class="python">for ... in...:
while ... :   #循环</code></pre>
<pre><code class="python"># range(x) 生成一个从0~x-1的整数序列  
for i in range(10):
    print(i)    #结果是0~9

for a in range(1,11):
    print(a)    #结果是1~10
#range(a,b)  从a开始向后b-a个数</code></pre>
<p>for循环适合一直循环次数的循环，所有后面跟的是次数或区间。</p>
<p>如果不知道要循环多少次才能达成目标，用while。</p>
<p>break 表示停止当前循环</p>
<pre><code class="python">for a in range(10):
    if a == 5:
        break
    print(a)</code></pre>
<p>continue 表示跳过当前循环轮次，去执行下一轮循环。</p>
<pre><code class="python">a = 0
while a &lt; 10:
    a = a + 1
    if a == 5:
        continue
    print(a)</code></pre>
<p><strong>建议遵守以下约定：</strong></p>
<ul>
<li><strong>使用 4 个空格来缩进</strong></li>
<li><strong>永远不要混用空格和制表符</strong></li>
<li><strong>在函数之间空一行</strong></li>
<li><strong>在类之间空两行</strong></li>
<li><strong>字典，列表，元组以及参数列表中，在 <code>,</code> 后添加一个空格。对于字典，<code>:</code> 后面也添加一个空格</strong></li>
<li><strong>在赋值运算符和比较运算符周围要有空格（参数列表中除外），但是括号里则不加空格：`a = f(1, 2) + g(3, 4)</strong>`</li>
</ul>
<p>:.2f 表示将float或int 保留小数点后两位，配合format使用</p>
<p><code>Year {} Rs. {:.2f}&quot;.format(year, value)</code> 称为字符串格式化，大括号和其中的字符会被替换成传入  <code>str.format()</code> 的参数，也即 <code>year</code> 和 <code>value</code>。其中 <code>{:.2f}</code> 的意思是替换为 2 位精度的浮点数。</p>
<p>一行内将多个值赋值给多个变量。</p>
<pre><code class="python">a , b = 45, 54
&gt;&gt;&gt; a
45
&gt;&gt;&gt; b
54</code></pre>
<p>只要有任意一个操作数是浮点数，结果就会是浮点数。</p>
<p>逻辑运算符的优先级又低于关系运算符，在它们之中，<code>not</code> 具有最高的优先级，<code>or</code> 优先级最低，所以 <code>A and not B or C</code> 等于 <code>(A and (notB)) or C</code>。</p>
<table>
<thead>
<tr>
<th>类型转换函数</th>
<th>转换路径</th>
</tr>
</thead>
<tbody><tr>
<td><code>float(string)</code></td>
<td>字符串 -&gt; 浮点值</td>
</tr>
<tr>
<td><code>int(string)</code></td>
<td>字符串 -&gt; 整数值</td>
</tr>
<tr>
<td><code>str(integer)</code></td>
<td>整数值 -&gt; 字符串</td>
</tr>
<tr>
<td><code>str(float)</code></td>
<td>浮点值 -&gt; 字符串</td>
</tr>
</tbody></table>
<p>print(b, end=’ ‘)   不换行</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>A[a,b] 得到列表中a到b的元素</p>
<pre><code class="python">&gt;&gt;&gt; a[1::2]
[342, &#39;India&#39;]  #它的意思是，从切片索引 1 到列表末尾，每隔两个元素取值。

&gt;&gt;&gt; a + [36, 49, 64, 81, 100]
[1, 342, 223, &#39;India&#39;, &#39;Fedora&#39;, 36, 49, 64, 81, 100]

&gt;&gt;&gt; cubes = [1, 8, 27, 65, 125]
&gt;&gt;&gt; cubes[3] = 64
&gt;&gt;&gt; cubes
[1, 8, 27, 64, 125]

&gt;&gt;&gt; letters = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]
&gt;&gt;&gt; letters
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]
&gt;&gt;&gt; # 替换某些值
&gt;&gt;&gt; letters[2:5] = [&#39;C&#39;, &#39;D&#39;, &#39;E&#39;]
&gt;&gt;&gt; letters
[&#39;a&#39;, &#39;b&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;f&#39;, &#39;g&#39;]
&gt;&gt;&gt; # 现在移除他们
&gt;&gt;&gt; letters[2:5] = []
&gt;&gt;&gt; letters
[&#39;a&#39;, &#39;b&#39;, &#39;f&#39;, &#39;g&#39;]
&gt;&gt;&gt; # 通过替换所有元素为空列表来清空这个列表
&gt;&gt;&gt; letters[:] = []
&gt;&gt;&gt; letters
[]</code></pre>
<p>要检查某个值是否存在于列表中，你可以这样做：</p>
<pre><code class="python">&gt;&gt;&gt; a = [&#39;ShiYanLou&#39;, &#39;is&#39;, &#39;cool&#39;]
&gt;&gt;&gt; &#39;cool&#39; in a
True
&gt;&gt;&gt; &#39;Linux&#39; in a
False</code></pre>
<p>如果你想要检查列表是否为空，请这样做：</p>
<pre><code class="python">if list_name: # 列表不为空
    pass
else: # 列表为空
    pass</code></pre>
<p>列表是允许嵌套的（创建一个包含其它列表的列表），例如：</p>
<pre><code class="python">&gt;&gt;&gt; a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; n = [1, 2, 3]
&gt;&gt;&gt; x = [a, n]
&gt;&gt;&gt; x
[[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], [1, 2, 3]]
&gt;&gt;&gt; x[0]
[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
&gt;&gt;&gt; x[0][1]
&#39;b&#39;</code></pre>
<p>判断True False 的首字母必须大写</p>
<p>a.insert()</p>
<pre><code class="python">a = [23, 45, 1, -3434, 43624356, 234]
&gt;&gt;&gt; a.append(45) # 在列表最后添加元素45

&gt;&gt;&gt; a.insert(0, 1) # 在列表索引 0 位置添加元素 1
&gt;&gt;&gt; a
[1, 23, 45, 1, -3434, 43624356, 234, 45]
&gt;&gt;&gt; a.insert(0, 111) 
&gt;&gt;&gt; a
[111, 1, 23, 45, 1, -3434, 43624356, 234, 45]

&gt;&gt;&gt; a.count(45) # 返回元素中45出现的次数
2

&gt;&gt;&gt; a.remove(234) # 去除元素234
&gt;&gt;&gt; a
[111, 1, 23, 45, 1, -3434, 43624356, 45]

&gt;&gt;&gt; a.reverse() # 反转整个列表
&gt;&gt;&gt; a
[45, 43624356, -3434, 1, 45, 23, 1, 111]

&gt;&gt;&gt; b = [45, 56, 90] # 将一个列表的所有元素添加到另一个列表的末尾
&gt;&gt;&gt; a.extend(b)
&gt;&gt;&gt; a
[45, 43624356, -3434, 1, 45, 23, 1, 111, 45, 56, 90]

&gt;&gt;&gt; a.sort() #　给列表排序，排序的前提是列表的元素是可比较的。
&gt;&gt;&gt; a
[-3434, 1, 1, 23, 45, 45, 45, 56, 90, 111, 43624356]

&gt;&gt;&gt; del a[-1] #也能使用 del 关键字删除指定位置的列表元素
&gt;&gt;&gt; a
[-3434, 1, 1, 23, 45, 45, 45, 56, 90, 111]</code></pre>
<h4 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h4><p><em>栈</em>　是我们通常所说的一种 <em>LIFO</em> （Last In First Out 后进先出）数据结构。</p>
<p><em>队列</em> 　是一种在末尾追加数据以及在开始弹出数据的数据结构。与栈不同，它是 <em>FIFO</em> （First In First Out 先进先出）的数据结构。</p>
<p><code>pop()</code>。传入一个参数 i 即 <code>pop(i)</code> 会将第 i 个元素弹出。</p>
<p><strong>列表推导式</strong></p>
<p>列表推导式由包含一个表达式的中括号组成，表达式后面跟随一个 for 子句，之后可以有零或多个 for 或 if 子句。结果是一个列表，由表达式依据其后面的 for 和 if 子句上下文计算而来的结果构成。</p>
<pre><code class="python">&gt;&gt;&gt; [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]

[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]</code></pre>
<p>列表推导式也可以嵌套</p>
<pre><code class="python">&gt;&gt;&gt; a=[1,2,3]
&gt;&gt;&gt; z = [x + 1 for x in [x ** 2 for x in a]]
&gt;&gt;&gt; z
[2, 5, 10]</code></pre>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组是由数个逗号分割的值组成。</p>
<p>你可以对任何一个元组执行拆封操作并赋值给多个变量</p>
<p>元组是不可变类型，这意味着你不能在元组内删除或添加或编辑任何值。</p>
<p>要创建只含有一个元素的元组，在值后面跟一个逗号。</p>
<pre><code class="python">&gt;&gt;&gt; a = (123)
&gt;&gt;&gt; a
123
&gt;&gt;&gt; type(a) # 判断类型
&lt;class &#39;int&#39;&gt;
&gt;&gt;&gt; a = (123, )
&gt;&gt;&gt; b = 321,
&gt;&gt;&gt; a
(123,)
&gt;&gt;&gt; b
(321,)
&gt;&gt;&gt; type(a)
&lt;class &#39;tuple&#39;&gt; # tuple 元组
&gt;&gt;&gt; type(b)
&lt;class &#39;tuple&#39;&gt;</code></pre>
<h5 id="元组和列表的区别"><a href="#元组和列表的区别" class="headerlink" title="元组和列表的区别"></a><em>元组和列表的区别</em></h5><p><em>列表是动态数组，它们不可变且可以重设长度（改变其内部元素的个数）。</em><br><em>元组是静态数组，它们不可变，且其内部数据一旦创建便无法改变。</em><br><em>元组缓存于Python运行时环境，这意味着我们每次使用元组时无须访问内核去分配内存。</em><br><em>这些区别结实率两者在设计哲学上的不同：</em></p>
<p><em>列表可被用于保存多个互相独立对象的数据集合</em><br><em>元组用于描述一个不会改不安的事务的多个属性</em></p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合是一个<strong>无序不重复元素</strong>的集。基本功能包括关系测试和消除重复元素</p>
<p>集合对象还支持 union（联合），intersection（交），difference（差）和 symmetric difference（对称差集）等数学运算。</p>
<p>想要创建空集合，你必须使用 set() 而不是 {}。后者用于创建空字典，</p>
<pre><code class="python">&gt;&gt;&gt; basket = {&#39;apple&#39;, &#39;orange&#39;, &#39;apple&#39;, &#39;pear&#39;, &#39;orange&#39;, &#39;banana&#39;}
&gt;&gt;&gt; print(basket)                      # 你可以看到重复的元素被去除
{&#39;orange&#39;, &#39;banana&#39;, &#39;pear&#39;, &#39;apple&#39;}
&gt;&gt;&gt; &#39;orange&#39; in basket
True
&gt;&gt;&gt; &#39;crabgrass&#39; in basket
False

&gt;&gt;&gt; # 演示对两个单词中的字母进行集合操作
...
&gt;&gt;&gt; a = set(&#39;abracadabra&#39;)
&gt;&gt;&gt; b = set(&#39;alacazam&#39;)
&gt;&gt;&gt; a                                  # a 去重后的字母
{&#39;a&#39;, &#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;}
&gt;&gt;&gt; a - b                              # a 有而 b 没有的字母
{&#39;r&#39;, &#39;d&#39;, &#39;b&#39;}
&gt;&gt;&gt; a | b                              # 存在于 a 或 b 的字母
{&#39;a&#39;, &#39;c&#39;, &#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;}
&gt;&gt;&gt; a &amp; b                              # a 和 b 都有的字母
{&#39;a&#39;, &#39;c&#39;}
&gt;&gt;&gt; a ^ b                              # 存在于 a 或 b 但不同时存在的字母
{&#39;r&#39;, &#39;d&#39;, &#39;b&#39;, &#39;m&#39;, &#39;z&#39;, &#39;l&#39;}</code></pre>
<p>从集合中添加或弹出元素：</p>
<pre><code class="python">&gt;&gt;&gt; a = {&#39;a&#39;,&#39;e&#39;,&#39;h&#39;,&#39;g&#39;}
&gt;&gt;&gt; a.pop()  # pop 方法随机删除一个元素并打印
&#39;h&#39;
&gt;&gt;&gt; a.add(&#39;c&#39;)
&gt;&gt;&gt; a
{&#39;c&#39;, &#39;e&#39;, &#39;g&#39;, &#39;a&#39;}</code></pre>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典是是无序的键值对（<code>key:value</code>）集合，同一个字典内的键必须是互不相同的。</p>
<p>值对，这也是字典输出的方式。</p>
<p>我们使用键来检索存储在字典中的数据。</p>
<p>创建新的键值：</p>
<pre><code class="python">&gt;&gt;&gt; data[&#39;parthan&#39;] = &#39;Ubuntu&#39;
&gt;&gt;&gt; data
{&#39;kushal&#39;: &#39;Fedora&#39;, &#39;Jace&#39;: &#39;Mac&#39;, &#39;kart_&#39;: &#39;Debian&#39;, &#39;parthan&#39;: &#39;Ubuntu&#39;}</code></pre>
<p>使用 <code>del</code> 关键字删除任意指定的键值对：</p>
<pre><code class="python">&gt;&gt;&gt; del data[&#39;kushal&#39;]
&gt;&gt;&gt; data
{&#39;Jace&#39;: &#39;Mac&#39;, &#39;kart_&#39;: &#39;Debian&#39;, &#39;parthan&#39;: &#39;Ubuntu&#39;
dict.clear()     # 清空字典
del dict         # 删除字典</code></pre>
<p>使用 <code>in</code> 关键字查询指定的键是否存在于字典中：</p>
<pre><code class="python">&gt;&gt;&gt; &#39;ShiYanLou&#39; in data
False</code></pre>
<p><em>字典中的键必须是不可变类型，比如你不能使用列表作为键。</em></p>
<p><code>dict()</code> 可以从包含键值对的元组中创建字典:</p>
<pre><code class="python">&gt;&gt;&gt; dict(((&#39;Indian&#39;,&#39;Delhi&#39;),(&#39;Bangladesh&#39;,&#39;Dhaka&#39;)))
{&#39;Indian&#39;: &#39;Delhi&#39;, &#39;Bangladesh&#39;: &#39;Dhaka&#39;}</code></pre>
<p>遍历字典的方法：</p>
<pre><code class="python">&gt;&gt;&gt; data
{&#39;Kushal&#39;: &#39;Fedora&#39;, &#39;Jace&#39;: &#39;Mac&#39;, &#39;kart_&#39;: &#39;Debian&#39;, &#39;parthan&#39;: &#39;Ubuntu&#39;}
&gt;&gt;&gt; for x, y in data.items():
...     print(&quot;{} uses {}&quot;.format(x, y))
...
Kushal uses Fedora
Jace uses Mac
kart_ uses Debian
parthan uses Ubuntu</code></pre>
<p>许多时候我们需要往字典中的元素添加数据，我们首先要判断这个元素是否存在，不存在则创建一个默认值。如果在循环里执行这个操作，每次迭代都需要判断一次，降低程序性能。</p>
<p>我们可以使用 <code>dict.setdefault(key, default)</code> 更有效率的完成这个事情。</p>
<pre><code class="python">&gt;&gt;&gt; data = {}
&gt;&gt;&gt; data.setdefault(&#39;names&#39;, []).append(&#39;Ruby&#39;)
&gt;&gt;&gt; data
{&#39;names&#39;: [&#39;Ruby&#39;]}
&gt;&gt;&gt; data.setdefault(&#39;names&#39;, []).append(&#39;Python&#39;)
&gt;&gt;&gt; data
{&#39;names&#39;: [&#39;Ruby&#39;, &#39;Python&#39;]}
&gt;&gt;&gt; data.setdefault(&#39;names&#39;, []).append(&#39;C&#39;)
&gt;&gt;&gt; data
{&#39;names&#39;: [&#39;Ruby&#39;, &#39;Python&#39;, &#39;C&#39;]}</code></pre>
<p>试图索引一个不存在的键将会抛出一个 keyError 错误。我们可以使用 dict.get(key, default) 来索引键，如果键不存在，那么返回指定的 default 值。</p>
<pre><code class="python">&gt;&gt;&gt; data[&#39;foo&#39;]
Traceback (most recent call last):
File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
KeyError: &#39;foo&#39;
&gt;&gt;&gt; data.get(&#39;foo&#39;, 0)
0</code></pre>
<p>在遍历列表（或任何序列类型）的同时获得元素索引值，你可以使用 <code>enumerate()</code></p>
<pre><code class="python">&gt;&gt;&gt; for i, j in enumerate([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]):
...     print(i, j)
...
0 a
1 b
2 c</code></pre>
<p>同时遍历两个序列类型，你可以使用 <code>zip()</code> 函数。</p>
<pre><code class="python">&gt;&gt;&gt; a = [&#39;Pradeepto&#39;, &#39;Kushal&#39;]
&gt;&gt;&gt; b = [&#39;OpenSUSE&#39;, &#39;Fedora&#39;]
&gt;&gt;&gt; for x, y in zip(a, b):
...     print(&quot;{} uses {}&quot;.format(x, y))
...
Pradeepto uses OpenSUSE
Kushal uses Fedora</code></pre>
<p>####　zip()</p>
<pre><code class="python">&gt;&gt;&gt;a = [1,2,3]
&gt;&gt;&gt; b = [4,5,6]
&gt;&gt;&gt; c = [4,5,6,7,8]
&gt;&gt;&gt; zipped = zip(a,b)     # 打包为元组的列表
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; zip(a,c)              # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]
&gt;&gt;&gt; zip(*zipped)          # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式
[(1, 2, 3), (4, 5, 6)]</code></pre>
<h4 id="计算两个矩阵的-Hadamard-乘积"><a href="#计算两个矩阵的-Hadamard-乘积" class="headerlink" title="计算两个矩阵的 Hadamard 乘积"></a>计算两个矩阵的 Hadamard 乘积</h4><pre><code class="python">n = int(input(&quot;Enter the value of n: &quot;))
print(&quot;Enter values for the Matrix A&quot;)
a = []
for i in range(n):
    a.append([int(x) for x in input().split()])
print(&quot;Enter values for the Matrix B&quot;)
b = []
for i in range(n):
    b.append([int(x) for x in input().split()])
c = []
for i in range(n):
    c.append([a[i][j] * b[i][j] for j in range(n)])
print(&quot;After matrix multiplication&quot;)
print(&quot;-&quot; * 7 * n)
for x in c:
    for y in x:
        print(str(y).rjust(5), end=&#39; &#39;)
    print()
print(&quot;-&quot; * 7 * n)</code></pre>
<h4 id="just-方法"><a href="#just-方法" class="headerlink" title="just()方法"></a>just()方法</h4><pre><code class="python">str.rjust(width[, fillchar])

str = &quot;this is string example....wow!!!&quot;;
print str.rjust(50, &#39;0&#39;);

000000000000000000this is string example....wow!!!</code></pre>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>如果你想要分几行输入字符串，并且希望行尾的换行符自动包含到字符串当中，可以使用三对引号：<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code></p>
<pre><code class="python">&gt;&gt;&gt; print(&quot;&quot;&quot;\
... Usage: thingy [OPTIONS]
...      -h                        Display this usage message
...      -H hostname               Hostname to connect to
... &quot;&quot;&quot;)
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to</code></pre>
<p>方法 <code>title()</code> 返回字符串的标题版本，即单词首字母大写其余字母小写</p>
<pre><code class="python">&gt;&gt;&gt; s = &quot;shi yan lou&quot;
&gt;&gt;&gt; s.title()
&#39;Shi Yan Lou&#39;</code></pre>
<p>方法 <code>upper()</code> 返回字符串全部大写的版本，反之 <code>lower()</code> 返回字符串的全部小写版本</p>
<pre><code class="python">&gt;&gt;&gt; z = s.upper()
&gt;&gt;&gt; z
&#39;SHI YAN LOU&#39;
&gt;&gt;&gt; z.lower()
&#39;shi yan lou&#39;</code></pre>
<p>方法 <code>swapcase()</code> 返回字符串大小写交换后的版本 :）</p>
<pre><code class="python">&gt;&gt;&gt; s = &quot;I am A pRoGraMMer&quot;
&gt;&gt; s.swapcase()
&#39;i AM a PrOgRAmmER&#39;</code></pre>
<p>方法 <code>isalnum()</code> 检查所有字符是否只有字母和数字，上面的代码中第一行的字符串 <code>s</code> 中包含空格字符，所以返回 <code>False</code></p>
<pre><code class="python">&gt;&gt;&gt; s = &quot;jdwb 2323bjb&quot;
&gt;&gt;&gt; s.isalnum()
False
&gt;&gt;&gt; s = &quot;jdwb2323bjb&quot;
&gt;&gt;&gt; s.isalnum()
True</code></pre>
<p>方法 <code>isalpha()</code> 检查字符串之中是否只有字母</p>
<pre><code class="python">&gt;&gt;&gt; s = &quot;SankarshanSir&quot;
&gt;&gt;&gt; s.isalpha()
True
&gt;&gt;&gt; s = &quot;Sankarshan Sir&quot;
&gt;&gt;&gt; s.isalpha()
False</code></pre>
<pre><code class="python">&gt;&gt;&gt; s = &quot;1234&quot;
&gt;&gt;&gt; s.isdigit() # 检查字符串是否所有字符为数字
True
&gt;&gt;&gt; s = &quot;ShiYanLou is coming&quot;
&gt;&gt;&gt; s.islower() # 检查字符串是否所有字符为小写
False
&gt;&gt;&gt; s = &quot;Shiyanlou Is Coming&quot;
&gt;&gt;&gt; s.istitle() # To 检查字符串是否为标题样式
True
&gt;&gt;&gt; s = &quot;CHINA&quot;
&gt;&gt;&gt; s.isupper() # 检查字符串是否所有字符为大写
True</code></pre>
<p>我们可以使用 <code>split()</code> 分割任意字符串，<code>split()</code> 允许有一个参数，用来指定字符串以什么字符分隔（默认为 <code>&quot; &quot;</code>），它返回一个包含所有分割后的字符串的列表。</p>
<pre><code class="python">&gt;&gt;&gt; s = &quot;We all love Python&quot;
&gt;&gt;&gt; s.split()
[&#39;We&#39;, &#39;all&#39;, &#39;love&#39;, &#39;Python&#39;]
&gt;&gt;&gt; x = &quot;shiyanlou:is:waiting&quot;
&gt;&gt;&gt; x.split(&#39;:&#39;)
[&#39;shiyanlou&#39;, &#39;is&#39;, &#39;waiting&#39;]</code></pre>
<p>方法 <code>join()</code> 使用指定字符连接多个字符串，它需要一个包含字符串元素的列表作为输入然后连接列表内的字符串元素</p>
<pre><code class="python">&gt;&gt;&gt; &quot;-&quot;.join(&quot;GNU/Linux is great&quot;.split())
&#39;GNU/Linux-is-great&#39;</code></pre>
<p> <code>strip(chars)</code>，用来剥离字符串首尾中指定的字符，它允许有一个字符串参数，这个参数为剥离哪些字符提供依据。不指定参数则默认剥离掉首尾的空格和换行符</p>
<pre><code class="python">&gt;&gt;&gt; s = &quot;  a bc\n &quot;
&gt;&gt;&gt; s.strip()
&#39;a bc&#39;</code></pre>
<p>你可以使用 <code>lstrip(chars)</code> 或 <code>rstrip(chars)</code> 只对字符串左或右剥离</p>
<pre><code class="python">&gt;&gt;&gt; s = &quot;www.foss.in&quot; 
&gt;&gt;&gt; s.lstrip(&quot;cwsd.&quot;) #删除在字符串左边出现的&#39;c&#39;,&#39;w&#39;,&#39;s&#39;,&#39;d&#39;,&#39;.&#39;字符
&#39;foss.in&#39;
&gt;&gt;&gt; s.rstrip(&quot;cnwdi.&quot;) #删除在字符串右边出现的&#39;c&#39;,&#39;n&#39;,&#39;w&#39;,&#39;d&#39;,&#39;i&#39;,&#39;.&#39;字符
&#39;www.foss&#39;</code></pre>
<h5 id="t-n-n-t在python中的用法"><a href="#t-n-n-t在python中的用法" class="headerlink" title="\t \n \n\t在python中的用法"></a>\t \n \n\t在python中的用法</h5><pre><code class="python">print(&quot;\tPython&quot;)#\t表示空四个字符，也称缩进，相当于按一下Tab键
print(&quot;\nPython&quot;)#\n表示换行，相当于按一下回车
print(&quot;languages:\n\tPython&quot;)#\n\t表示换行加每行空四格</code></pre>
<p><code>find()</code> 能帮助你找到第一个匹配的子字符串，没有找到则返回 -1</p>
<pre><code class="python">&gt;&gt;&gt; s = &quot;faulty for a reason&quot;
&gt;&gt;&gt; s.find(&quot;for&quot;)
7
&gt;&gt;&gt; s.find(&quot;fora&quot;)
-1
&gt;&gt;&gt; s.startswith(&quot;fa&quot;) # 检查字符串是否以 fa 开头
True
&gt;&gt;&gt; s.endswith(&quot;reason&quot;) # 检查字符串是否以 reason 结尾
True</code></pre>
<p>检查回文</p>
<pre><code class="python">#!/usr/bin/env python3
s = input(&quot;Please enter a string: &quot;)
z = s[::-1]  #把输入的字符串s 进行倒序处理形成新的字符串z
if s == z:
    print(&quot;The string is a palindrome&quot;)
else:
    print(&quot;The string is not a palindrome&quot;)</code></pre>
<h4 id="格式化操作符"><a href="#格式化操作符" class="headerlink" title="格式化操作符%"></a>格式化操作符%</h4><p>%s 字符串（用 str() 函数进行字符串转换）</p>
<p>%r 字符串（用 repr() 函数进行字符串转换）</p>
<p>%d 十进制整数</p>
<p>%f 浮点数</p>
<p>%% 字符“%”</p>
<pre><code class="python"># 对用户输入的一行文本进行单词计数
s = input(&quot;Enter a line: &quot;)
print(&quot;The number of words in the line are %d&quot; % (len(s.split(&quot; &quot;))))</code></pre>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>定义全局变量global</p>
<pre><code class="python">def change():
    global a
    a = 90
    print(a)

a = 9
print(&quot;Before the function call &quot;, a)
print(&quot;inside change function&quot;, end=&#39; &#39;)
change()
print(&quot;After the function call &quot;, a)</code></pre>
<p>默认参数值</p>
<ul>
<li><p>具有默认值的参数后面不能再有普通参数</p>
</li>
<li><p>默认值只被赋值一次，因此如果默认值是任何可变对象时会有所不同，比如列表、字典或大多数类的实例。</p>
</li>
</ul>
<p>我们也能将函数的参数标记为只允许使用关键字参数。用户调用函数时将只能对每一个参数使用相应的关键字参数。</p>
<pre><code class="python">&gt;&gt;&gt; def hello(*, name=&#39;User&#39;):
...     print(&quot;Hello&quot;, name)
...
&gt;&gt;&gt; hello(&#39;shiyanlou&#39;)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: hello() takes 0 positional arguments but 1 was given
&gt;&gt;&gt; hello(name=&#39;shiyanlou&#39;)
Hello shiyanlou</code></pre>
<p>文档字符串</p>
<pre><code class="python">#!/usr/bin/env python3
import math

def longest_side(a, b):
    &quot;&quot;&quot;
    Function to find the length of the longest side of a right triangle.

    :arg a: Side a of the triangle
    :arg b: Side b of the triangle

    :return: Length of the longest side c as float
    &quot;&quot;&quot;
    return math.sqrt(a*a + b*b)

if __name__ == &#39;__main__&#39;:
    print(longest_side.__doc__)
    print(longest_side(4,5))</code></pre>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶函数（<em>Higher-order function</em>）或仿函数（<em>functor</em>）是可以接受函数作为参数的函数：</p>
<ul>
<li>使用一个或多个函数作为参数</li>
<li>返回另一个函数作为输出</li>
</ul>
<p>Python 里的任何函数都可以作为高阶函数，下面举一个简单的例子：</p>
<pre><code class="python"># 创建一个函数，将参数列表中每个元素都变成全大写
&gt;&gt;&gt; def high(l):
...     return [i.upper() for i in l]
...
# 创建高阶函数，接受一个函数和一个列表作为参数
&gt;&gt;&gt; def test(h, l):
...     return h(l)
...
&gt;&gt;&gt; l = [&#39;python&#39;, &#39;Linux&#39;, &#39;Git&#39;]
# 运行高阶函数，返回预期的结果
&gt;&gt;&gt; test(high, l)
[&#39;PYTHON&#39;, &#39;LINUX&#39;, &#39;GIT&#39;]</code></pre>
<h4 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h4><p><code>map</code> 是一个在 Python 里非常有用的高阶函数。它接受一个函数和一个序列（迭代器）作为输入，然后对序列（迭代器）的每一个值应用这个函数，返回一个序列（迭代器），其包含应用函数后的结果。</p>
<p>举例：</p>
<pre><code class="python">&gt;&gt;&gt; lst = [1, 2, 3, 4, 5]
&gt;&gt;&gt; def square(num):
...     &quot;返回所给数字的平方.&quot;
...     return num * num
...
&gt;&gt;&gt; print(list(map(square, lst)))
[1, 4, 9, 16, 25]</code></pre>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="open-函数"><a href="#open-函数" class="headerlink" title="open() 函数"></a><code>open()</code> 函数</h3><p>它需要两个参数，第一个参数是文件路径或文件名，第二个是文件的打开模式。模式通常是下面这样的：</p>
<ul>
<li><code>&quot;r&quot;</code>，以只读模式打开，你只能读取文件但不能编辑/删除文件的任何内容</li>
<li><code>&quot;w&quot;</code>，以写入模式打开，如果文件存在将会删除里面的所有内容，然后打开这个文件进行写入</li>
<li><code>&quot;a&quot;</code>，以追加模式打开，写入到文件中的任何数据将自动添加到末尾</li>
</ul>
<p>默认的模式为只读模式，也就是说如果你不提供任何模式，<code>open()</code> 函数将会以只读模式打开文件。</p>
<p>使用 <code>read()</code> 方法一次性读取整个文件。</p>
<pre><code class="python">&gt;&gt;&gt; fobj = open(&quot;sample.txt&quot;)
&gt;&gt;&gt; fobj.read()
&#39;I love Python\nI love shiyanlou\n&#39;
&gt;&gt;&gt; fobj.close()</code></pre>
<p>如果你再一次调用 <code>read()</code>，它会返回空字符串因为它已经读取完整个文件。</p>
<p><code>read(size)</code> 有一个可选的参数 <code>size</code>，用于指定字符串长度。如果没有指定 <code>size</code> 或者指定为负数，就会读取并返回整个文件。当文件大小为当前机器内存两倍时，就会产生问题。反之，会尽可能按比较大的 <em>size</em> 读取和返回数据。</p>
<p><code>readline()</code> 能帮助你每次读取文件的一行。</p>
<pre><code class="python">&gt;&gt;&gt; fobj = open(&quot;sample.txt&quot;)
&gt;&gt;&gt; fobj.readline()
&#39;I love Python\n&#39;
&gt;&gt;&gt; fobj.readline()
&#39;I love shiyanlou\n&#39;
&gt;&gt;&gt; fobj.close()</code></pre>
<p>使用 <code>readlines()</code> 方法读取所有行到一个列表中。</p>
<pre><code class="python">&gt;&gt;&gt; fobj = open(&#39;sample.txt&#39;)
&gt;&gt;&gt; fobj.readlines()
[&#39;I love Python\n&#39;, &#39;I love shiyanlou\n&#39;]
&gt;&gt;&gt; fobj.close()</code></pre>
<p>你可以循环遍历文件对象来读取文件中的每一行。</p>
<pre><code class="python">&gt;&gt;&gt; fobj = open(&#39;sample.txt&#39;)
&gt;&gt;&gt; for x in fobj:
...     print(x, end = &#39;&#39;)
... 
I love Python
I love shiyanlou
&gt;&gt;&gt; fobj.close()</code></pre>
<p>让我们写一个程序，这个程序接受用户输入的字符串作为将要读取的文件的文件名，并且在屏幕上打印文件内容。</p>
<pre><code class="python">#!/usr/bin/env python3
name = input(&quot;Enter the file name: &quot;)
fobj = open(name)
print(fobj.read())
fobj.close()</code></pre>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><pre><code class="python">&#39;&#39;&#39;
try：
    程序
except Exception as 异常名:
    异常处理部分
&#39;&#39;&#39;
try:
    for i in range(0,10)
        print(i)
        if（i==4）
            print（abc）
        print（&quot;1&quot;）
except Exception as err:
    print(err)</code></pre>
<h2 id="构造函数与函数的区别"><a href="#构造函数与函数的区别" class="headerlink" title="构造函数与函数的区别"></a>构造函数与函数的区别</h2><ol>
<li><p>返回值类型的区别：</p>
<pre><code>   1. 构造函数是没有返回值类型的。
   2. 普通函数是有返回值类型的，即使函数没有返回值，返回值类型也要写上void。</code></pre></li>
<li><p>函数名的区别：</p>
<ol>
<li>构造函数的函数名必须要与类名一致，</li>
<li>普通函数的函数名只要符合标识符的命名规则即可。</li>
</ol>
</li>
<li><p>调用方式的区别：</p>
<ol>
<li>构造函数是 在创建对象的时候由jvm调用的。</li>
<li>普通函数是由我们使用对象调用的，一个对象可以对象多次普通的函数，</li>
</ol>
</li>
<li><p>作用上的区别：</p>
<ol>
<li>构造函数 的作用用于初始化一个对象。</li>
<li>普通函数是用于描述一类事物的公共行为的。</li>
</ol>
</li>
</ol>

            
        </article>
    </div>
    
</section>

    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/combine/npm/lazysizes@5.1.0/lazysizes.min.js,gh/highlightjs/cdn-release@9.15.8/build/highlight.min.js,npm/mdui@0.4.3/dist/js/mdui.min.js,gh/nexmoe/nexmoe.github.io@latest/js/app.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<!--<script src="/js/app.js?v=1584084642467"></script>-->


    <script src="https://cdn.jsdelivr.net/gh/xtaodada/xtaodada.github.io@0.0.2/copy.js"></script>



  





</body>

</html>
